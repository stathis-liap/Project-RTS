#version 330 core

// Interpolated inputs from vertex shader
in vec3 Position_worldspace;
in vec3 Position_cameraspace;
in vec3 Normal_cameraspace;
in vec2 UV;
in vec3 LightDirection_cameraspace;
in vec4 FragPosLightSpace;  // ← NEW: from vertex shader

// Output
out vec4 fragmentColor;

// Uniforms
uniform int useTexture = 0;
uniform sampler2D diffuseColorSampler;
uniform sampler2D specularColorSampler;
uniform sampler2D shadowMap;         // ← NEW: depth texture from shadow pass
uniform mat4 lightSpaceMatrix;       // ← NEW: for debugging/reconstruction if needed (optional)

// Light
struct Light {
    vec4 La;
    vec4 Ld;
    vec4 Ls;
    float power;
};
uniform Light light;

// Material
struct Material {
    vec4 Ka;
    vec4 Kd;
    vec4 Ks;
    float Ns;
};
uniform Material mtl;

// -------------------------------------------------------
// Shadow calculation with slope-scaled bias + PCF (3x3)
// -------------------------------------------------------
float calculateShadow(vec4 fragPosLightSpace)
{
    // Perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // Transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    
    // Early out if outside shadow map
    if (projCoords.z > 1.0 ||
        projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float currentDepth = projCoords.z;
    
    // ✅ REDUCED bias - was too aggressive and removing shadows
    vec3 normal = normalize(Normal_cameraspace);
    vec3 lightDir = normalize(LightDirection_cameraspace);
    float cosTheta = clamp(dot(normal, lightDir), 0.0, 1.0);
    
    // Much smaller bias values
    float bias = 0.00005 + (1.0 - cosTheta) * 0.0002;
    bias = clamp(bias, 0.00001, 0.0005);  // ✅ 10x smaller than before
    
    // PCF 3x3 sampling for soft shadows
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += (currentDepth - bias > pcfDepth) ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;
    
    return shadow;
}

void main()
{
    // --- Load material (with optional texture override) ---
    vec4 Ka = mtl.Ka;
    vec4 Kd = mtl.Kd;
    vec4 Ks = mtl.Ks;
    float Ns = mtl.Ns;

    if (useTexture == 1) {
        Kd = vec4(texture(diffuseColorSampler, UV).rgb, 1.0);
        Ks = vec4(texture(specularColorSampler, UV).rgb, 1.0);
        Ka = vec4(0.1, 0.1, 0.1, 1.0);
        Ns = 10.0;
    }

    // --- Phong lighting (directional) ---
    vec3 N = normalize(Normal_cameraspace);
    vec3 L = normalize(LightDirection_cameraspace);
    vec3 E = normalize(-Position_cameraspace); // view direction

    // Ambient
    vec4 Ia = light.La * Ka;

    // Diffuse
    float cosTheta = clamp(dot(N, L), 0.0, 1.0);
    vec4 Id = light.Ld * Kd * cosTheta;

    // Specular (Blinn-Phong optional, but classic reflect works fine)
    vec3 R = reflect(-L, N);
    float cosAlpha = clamp(dot(E, R), 0.0, 1.0);
    vec4 Is = light.Ls * Ks * pow(cosAlpha, Ns);

    // --- Shadow factor ---
    float shadow = calculateShadow(FragPosLightSpace);

    // --- Final color: apply shadow to diffuse + specular only ---
    vec4 litColor = Ia + (1.0 - shadow) * (Id + Is) * light.power;

    fragmentColor = vec4(litColor.rgb, 1.0);
}