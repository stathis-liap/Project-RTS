#version 330 core

// Interpolated inputs from vertex shader
in vec3 Position_worldspace;
in vec3 Position_cameraspace;
in vec3 Normal_cameraspace;
in vec2 UV;
in vec3 LightDirection_cameraspace;
in vec4 FragPosLightSpace;  // from vertex shader

in float ClipHeight;

// Output
out vec4 fragmentColor;

// Uniforms
uniform int useTexture = 0;
uniform sampler2D diffuseColorSampler;
uniform sampler2D specularColorSampler;
uniform sampler2D shadowMap;         // depth texture from shadow pass
uniform mat4 lightSpaceMatrix;       // for debugging/reconstruction if needed (optional)
uniform float constructionProgress;

// Light
struct Light {
    vec4 La;
    vec4 Ld;
    vec4 Ls;
    float power;
};
uniform Light light;

// Material
struct Material {
    vec4 Ka;
    vec4 Kd;
    vec4 Ks;
    float Ns;
};
uniform Material mtl;

// -------------------------------------------------------
// Shadow calculation with slope-scaled bias + PCF (3x3)
// -------------------------------------------------------
float calculateShadow(vec4 fragPosLightSpace)
{
    // Perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // Transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    
    // Early out if outside shadow map
    if (projCoords.z > 1.0 ||
        projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float currentDepth = projCoords.z;
    
    vec3 normal = normalize(Normal_cameraspace);
    vec3 lightDir = normalize(LightDirection_cameraspace);
    float cosTheta = clamp(dot(normal, lightDir), 0.0, 1.0);
    
    // Much smaller bias values
    float bias = 0.00005 + (1.0 - cosTheta) * 0.0002;
    bias = clamp(bias, 0.00001, 0.0005);  
    
    // PCF 3x3 sampling for soft shadows
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += (currentDepth - bias > pcfDepth) ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;
    
    return shadow;
}

void main()
{
    // Discard fragments above construction line (with small epsilon for precision)
    if (ClipHeight > 0.001) {
        discard;
    }
   
    // fade effect near the construction edge ONLY during construction
    float edgeFade = 1.0;
    if (constructionProgress < 1.0 && ClipHeight > -0.5) { // Within 0.5 units of edge
        edgeFade = smoothstep(-0.5, 0.0, ClipHeight);
        edgeFade = 1.0 - edgeFade; // Invert so 0 = transparent
    }
    // --- Load material (with optional texture override) ---
    vec4 Ka = mtl.Ka;
    vec4 Kd = mtl.Kd;
    vec4 Ks = mtl.Ks;
    float Ns = mtl.Ns;
    if (useTexture == 1) {
        Kd = vec4(texture(diffuseColorSampler, UV).rgb, 1.0);
        Ks = vec4(texture(specularColorSampler, UV).rgb, 1.0);
        Ka = vec4(0.1, 0.1, 0.1, 1.0);
        Ns = 10.0;
    }
    // --- Phong lighting (directional) - use .rgb only ---
    vec3 N = normalize(Normal_cameraspace);
    vec3 L = normalize(LightDirection_cameraspace);
    vec3 E = normalize(-Position_cameraspace); // view direction
    // Ambient
    vec3 Ia = light.La.rgb * Ka.rgb;
    // Diffuse
    float cosTheta = clamp(dot(N, L), 0.0, 1.0);
    vec3 Id = light.Ld.rgb * Kd.rgb * cosTheta;
    // Specular (Blinn-Phong optional, but classic reflect works fine)
    vec3 R = reflect(-L, N);
    float cosAlpha = clamp(dot(E, R), 0.0, 1.0);
    vec3 Is = light.Ls.rgb * Ks.rgb * pow(cosAlpha, Ns);
    // --- Shadow factor ---
    float shadow = calculateShadow(FragPosLightSpace);
    // --- Final color: apply shadow to diffuse + specular only ---
    vec3 litRgb = Ia + (1.0 - shadow) * (Id + Is) * light.power;
    // Alpha separate (from Kd.a, for transparency)
    float finalAlpha = Kd.a * edgeFade;
    fragmentColor = vec4(litRgb, finalAlpha);
}