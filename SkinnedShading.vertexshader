#version 330 core

// --- INPUTS ---
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;
layout(location = 2) in vec2 vertexUV;
layout(location = 3) in ivec4 boneIDs;  // Skinning
layout(location = 4) in vec4 weights;   // Skinning

// --- OUTPUTS (To Fragment Shader) ---
out vec3 Position_worldspace;
out vec3 Position_cameraspace;
out vec3 Normal_cameraspace;
out vec2 UV;
out vec3 LightDirection_cameraspace;
out vec4 FragPosLightSpace; // For Shadows
out float ClipHeight;       // For Construction Effect

// --- UNIFORMS ---
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;

// Lighting & Shadows
uniform mat4 lightSpaceMatrix;
uniform vec3 lightDirection_worldspace;

// Construction
uniform float constructionProgress;
uniform float buildingHeight;
uniform vec3 buildingBasePos;

// Skinning
uniform mat4 finalBonesMatrices[250];

void main(){
    
    // ------------------------------------------------
    // 1. CALCULATE BONE TRANSFORM
    // ------------------------------------------------
    mat4 BoneTransform = mat4(0.0);
    float totalWeight = 0.0;
    
    for(int i = 0; i < 4; i++){
        if(boneIDs[i] != -1 && boneIDs[i] < 250){
            BoneTransform += finalBonesMatrices[boneIDs[i]] * weights[i];
            totalWeight += weights[i];
        }
    }
    
    // Safety: If no bones affect this vertex, keep it static (Identity Matrix)
    if (totalWeight < 0.01) {
        BoneTransform = mat4(1.0);
    }

    // ------------------------------------------------
    // 2. APPLY BONES TO POSITION & NORMAL
    // ------------------------------------------------
    // Apply bones to the raw model position
    vec4 localPosition = BoneTransform * vec4(vertexPosition_modelspace, 1.0);
    
    // Apply bones to the raw normal (Rotation only, so use mat3)
    vec3 localNormal   = mat3(BoneTransform) * vertexNormal_modelspace;

    // ------------------------------------------------
    // 3. STANDARD LIGHTING CALCULATION (Using Animated Values)
    // ------------------------------------------------
    
    // Move to World Space using 'M'
    vec4 worldPos = M * localPosition; 
    
    gl_Position = P * V * worldPos;

    // Pass data to Fragment Shader
    Position_worldspace = worldPos.xyz;
    Position_cameraspace = (V * worldPos).xyz;
    
    // Calculate Normal in Camera Space
    // Note: We apply BoneTransform first, THEN Model, THEN View
    Normal_cameraspace = normalize(mat3(V * M) * localNormal);
    
    UV = vertexUV;
    
    // Lighting Vectors
    LightDirection_cameraspace = normalize(mat3(V) * lightDirection_worldspace);
    FragPosLightSpace = lightSpaceMatrix * worldPos;

    // Construction Clipping
    // We use the ANIMATED world position, so crouched units clip correctly!
    float relativeHeight = worldPos.y - buildingBasePos.y;
    float clipThreshold = buildingHeight * constructionProgress;
    ClipHeight = relativeHeight - clipThreshold;
}